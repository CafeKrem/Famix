"
Description
--------------------

I am an abstract class defining the basic behavior of Moose objects.

Moose Object can have a state (see bellow) and are initialized with an ID. The ID should be unique inside an image. This means that when we export and re-import an entity, the ID can change.

Note: (Cyril F) In the future I would like to push down mooseID on MooseEntity becaure I think that groups should not have an ID, but we need to refactor some things to do that.


Extension mechanism
--------------------

The state instance variable provides a mechanism for extending the state of entities. This is achieved through MooseEntityState. Using this mechanism, a package can extend an entity to add more state. This extension will only be visible when the package is loaded. This is an important mechanism to enable extensibility and modularity. 

For example, if you have YourEntity that subclasses MooseEntity, you can extend it with:

YourEntity>>yourExtendingAttribute
	^ self privateState attributeAt: #yourExtendingAttribute
YourEntity>>yourExtendingAttribute: aValue
	^ self privateState attributeAt: #yourExtendingAttribute put: aValue

(see MooseEntityState for more information)

Public API and Key Messages
--------------------

- mooseDescription - returns the corresponding FM3Class instance
- mooseName - returns a symbol that should qualify the current entity. It does not have to be unique
- mooseID is an Integer that uniquely identifies this entity within the entire Moose environment. 
	It should not change nor be nil. It is generated automatically during the creation of the MooseEntity.
 
Internal Representation and Key Implementation Points.
--------------------

    Instance Variables
	mooseID:		<anInteger>					The unique ID of the object in Moose.
	state:			<aMooseEntityState>		A state on which we base the extension mechanism of Moose.

"
Class {
	#name : #MooseObject,
	#superclass : #Object,
	#instVars : [
		'state',
		'mooseID',
		'mooseName'
	],
	#classVars : [
		'DefaultState',
		'MooseID'
	],
	#classInstVars : [
		'cache'
	],
	#category : #'Moose-Core'
}

{ #category : #meta }
MooseObject class >> allDeclaredProperties [
	"All properties described in the metamodel"

	^ self mooseDescription allProperties
]

{ #category : #accessing }
MooseObject class >> allPropertySelectors [
	"Return a dictionary with all properties of this kind of entity, including metamodel properties, metrics, and navigation groups. Keys are abstract names of properties, values are implementing selectors"

	| props |
	props := IdentityDictionary new.
	self allDeclaredProperties do: [ :prop | props at: prop name put: prop implementingSelector ].
	self navigationPragmas do: [ :p | props at: p selector put: p selector ].
	^ props
]

{ #category : #meta }
MooseObject class >> annotation [
	<FMClass: #Object super: #Object>
	<package: #Moose>
	<abstract>
]

{ #category : #accessing }
MooseObject class >> cache [
	^ cache ifNil: [ self initializeCache ]
]

{ #category : #accessing }
MooseObject class >> defaultState [
	^ DefaultState ifNil: [ DefaultState := MooseEntityState ]
]

{ #category : #accessing }
MooseObject class >> defaultState: anObject [
	DefaultState := anObject
]

{ #category : #private }
MooseObject class >> freshID [
	"Answer a fresh ID, which is unique within Moose."

	nil == MooseID ifTrue: [ MooseID := 0 ].
	MooseID := 1 + MooseID.
	MooseID > SmallInteger maxVal
		ifTrue: [ Notification
				signal:
					'Moose''s internal element IDs are exceeding the range of SmallInteger, '
						, 'this may cause system slow down.<n> Please contact moose-dev@iam.unibe.ch for more information.' ].
	^ MooseID
]

{ #category : #accessing }
MooseObject class >> initializeCache [
	"Usually we use #at:ifAbsentPut: to declare new properties, but in MooseQuery to reduce too much the perfs to instantiate the block as second argument. Thus, we initialize this info direction at the cache creation and use a simple #at: instead"

	^ cache := SmallDictionary new
		at: #usedStatefulTraits put: super usedStatefulTraits;
		at: #superclassesAndFamixTraits put: super usedStatefulTraits , self withAllSuperclasses;
		yourself
]

{ #category : #testing }
MooseObject class >> isAbstract [
	^ self = MooseObject
]

{ #category : #testing }
MooseObject class >> isOfType: aClassFAMIX [
	^ self superclassesAndFamixTraits includes: aClassFAMIX
]

{ #category : #accessing }
MooseObject class >> navigationPragmas [
	^ Pragma allNamed: #navigation: from: self to: MooseObject
]

{ #category : #'as yet unclassified' }
MooseObject class >> relatedGroupType [
	" The entities can specify what is the prefered type of MooseGroup they want to be stored in.
	They do that using a class side method with uniqueName that contains pragma <mooseGroup>. 
	Because such methods are stored mostly in traits and a class can have more than prefered group
	type, the most specialize one selected."

	| definingMethods selectedMethods selectedMethod |
	definingMethods :=(Pragma allNamed: #mooseGroup from: self class to: Object) collect: #method.
	definingMethods ifEmpty: [ ^ MooseSpecializedGroup ].

	"We need to find the most specialized method, so we select the lower in the hierarchy."
	selectedMethods := definingMethods groupedBy: [ :each | each methodClass withAllSuperclasses size ].
	selectedMethods := selectedMethods at: selectedMethods keys max.

	"In case multiple of such methods are found, we take the one that is the closest to be a local method. This means that if a method come from a trait of the class, it will be selected over a method that comes from a trait of a trait."
	selectedMethod := (selectedMethods sorted: [ :method1 :method2 | method1 origin allTraits includes: method2 origin ]) first.
	^ self perform: selectedMethod selector
]

{ #category : #private }
MooseObject class >> resetIDGeneration [ 
	"Resets the internal ID generation." 
	 
	MooseID := nil
]

{ #category : #initialization }
MooseObject class >> resetMooseEntityCache [
	cache := nil
]

{ #category : #private }
MooseObject class >> setMooseID: anInteger [
	"This method is used in the unit test"
	
	MooseID := anInteger 
]

{ #category : #testing }
MooseObject class >> superclassesAndFamixTraits [
	^ self cache directAt: #superclassesAndFamixTraits
]

{ #category : #testing }
MooseObject class >> usedStatefulTraits [
	^ self cache directAt: #usedStatefulTraits
]

{ #category : #'meta information' }
MooseObject >> allDeclaredProperties [
	"Do not use the class side version

This method allows us to look for its properties in the metadescription.
And, the metadescription might be different in the instance and in the class side since we can define for each instance its metamodel (with more or less properties)"
	^ self mooseDescription allProperties
]

{ #category : #'meta information' }
MooseObject >> allPropertySelectors [
	^ self class allPropertySelectors
]

{ #category : #private }
MooseObject >> announcer [
	^ self privateState attributeAt: #announcer ifAbsentPut: [Announcer new]
]

{ #category : #private }
MooseObject >> announcer: anAnnouncer [
	^ self privateState attributeAt: #announcer put: anAnnouncer
]

{ #category : #accessing }
MooseObject >> bookmarkAs: aString [
	"Adds myself in the cache of the mooseModel and mark it as a bookmark"
	| group |
	group := self asMooseGroup description: aString.
	group isBookmarked: true.
	^ self mooseModel add: group asBookmark: aString
]

{ #category : #private }
MooseObject >> defaultStateClass [
	"Answer the default implementator of this element's state."

	^ self class defaultState
]

{ #category : #accessing }
MooseObject >> description [
	^ self privateState description
]

{ #category : #accessing }
MooseObject >> description: characters [ 
	 
	self privateState description: characters
]

{ #category : #groups }
MooseObject >> entityCache [
	"should be used read only, i.e. you are not supposed to modify the returned groups.
	If you want to change entityGroups, use privateState 'set' methods"

	^ self privateState entityCache
]

{ #category : #groups }
MooseObject >> groupFor: aSelector [
	"Return a group containing elements corresponding to aSelector"

	"aSelector = allPackages, allClasses, allMethods, ... "

	^ MooseSpecializedGroup
		withAll: (self perform: aSelector) asCollection
		withDescription: aSelector asString capitalized , ' in ' , self mooseName
]

{ #category : #printing }
MooseObject >> gtDisplayOn: aStream [ 
	self mooseNameOn: aStream
]

{ #category : #testing }
MooseObject >> hasMooseModel [
	^ self mooseModel isNotNil
]

{ #category : #initialization }
MooseObject >> initialize [
	super initialize.

	mooseID := self class freshID.
	self resetPrivateState
]

{ #category : #accessing }
MooseObject >> isBookmarked [
	^ self propertyNamed: #isBookmarked ifNil: [false]
]

{ #category : #accessing }
MooseObject >> isBookmarked: aBoolean [
	self propertyNamed: #isBookmarked put: aBoolean
]

{ #category : #testing }
MooseObject >> isMooseModel [
	^ false
]

{ #category : #testing }
MooseObject >> isOfType: aClassFAMIX [
	^ self class isOfType: aClassFAMIX
]

{ #category : #properties }
MooseObject >> lookUpPropertyNamed: selector computedAs: aBlock [ 
	 
	^self privateState cache: selector initializer: aBlock
]

{ #category : #accessing }
MooseObject >> metamodel [
	^ self mooseModel
		ifNil: [ super metamodel ]
		ifNotNil: [ :aModel | aModel metamodel ]

]

{ #category : #accessing }
MooseObject >> mooseDescription [
	^ self mooseModel
		ifNil: [ super mooseDescription ]
		ifNotNil: [ :model | model mooseDescriptionFor: self class ]
]

{ #category : #accessing }
MooseObject >> mooseID [
	"Returns an unique identifier of this entity.  This method is mandatory, and must 
	return	 an Integer that uniquely identifies this entity within the entire Moose environment.
	The return value must not be nil, and must never change."

	"nil = mooseID ifTrue: [mooseID := MooseModel freshID]."

	^ mooseID
]

{ #category : #printing }
MooseObject >> mooseName [
	"The return value must not be nil, and must never change.
	The implementation should be fast, as this key may be used
	extensively by MooseGroup or similar facilities.
	
	Do not override this method.
	Instead, use mooseNameOn: to customize the result."

	self hasMooseModel
		ifFalse: [ "do not cache yet"
			| stream |
			stream := (String new: 64) writeStream.
			self mooseNameOn: stream.
			^ stream contents asSymbol ].
	^ mooseName
		ifNil: [ | stream |
			stream := (String new: 64) writeStream.
			self mooseNameOn: stream.
			mooseName := stream contents asSymbol ]
]

{ #category : #printing }
MooseObject >> mooseNameOn: aStream [
	"Hook to customize the rendered text of an entity. Do not specialize mooseName, but change/specialize this method if necessary."

	self mooseID
		ifNil: [ aStream nextPutAll: 'nil mooseID!!!' ]
		ifNotNil: [ self name ifNil: [ aStream print: self mooseID ] ifNotNil: [ aStream nextPutAll: self name ] ]
]

{ #category : #accessing }
MooseObject >> name [
	^ #noname
]

{ #category : #accessing }
MooseObject >> navigationPragmas [
	^ self class navigationPragmas
]

{ #category : #'meta information' }
MooseObject >> navigationSelectors [
	^ self navigationPragmas collect: #methodSelector
]

{ #category : #properties }
MooseObject >> notExistentMetricValue [
	
	^-1
]

{ #category : #printing }
MooseObject >> printOn: aStream [
	super printOn: aStream.
	aStream
		space;
		print:
			([ self mooseName ]
				on: Error
				do: [ 'Error printing the object' ])
]

{ #category : #private }
MooseObject >> privateClearMooseName [
	" this method causes the cache to fail if called directly. Use resetMooseName instead. "

	mooseName := nil
]

{ #category : #private }
MooseObject >> privateSetMooseModel: aMooseModel [
	"Do nothing in Object"
]

{ #category : #private }
MooseObject >> privateState [

	^ state
]

{ #category : #private }
MooseObject >> privateState: aState [

	state := aState.
	aState entity: self.
]

{ #category : #private }
MooseObject >> properties [ 
	 
	"for read only uses, i.e. don't change the returned value"
	
	^self privateState allCachedValues
]

{ #category : #properties }
MooseObject >> propertyNamed: propertyName [ 
	"Return the value of the property named propertyName, return nil if the property does not exist"

	^ self propertyNamed: propertyName ifNil: [ nil ]

]

{ #category : #properties }
MooseObject >> propertyNamed: propertyName ifAbsent: aBlock [
	"Return the value of the property named propertyName, evaluate aBlock if the property does not exist"

	| prop |
	prop := propertyName asSymbol.
	^ self privateState
		cacheAt: prop
		ifAbsent: [ | property |
			[ property := self mmGetProperty: (self mooseDescription propertyNamed: propertyName) ]
				on: Error
				do: [ :ex | property := nil ].
			property ifNil: [ aBlock value ] ]
]

{ #category : #properties }
MooseObject >> propertyNamed: name ifAbsentPut: value [
	^ self privateState cacheAt: name ifAbsentPut: value
]

{ #category : #properties }
MooseObject >> propertyNamed: propertyName ifNil: aBlock [
	"Return the value of the property named propertyName, evaluate aBlock if the property does not exist"

	| prop |
	prop := propertyName asSymbol.
	^ self privateState
		cacheAt: prop
		ifAbsent: [ | property |
			[ property := self mmGetProperty: (self mooseDescription propertyNamed: propertyName) ]
				on: Error
				do: [ :ex | property := nil ].
			property ifNil: [ aBlock value ] ]
]

{ #category : #properties }
MooseObject >> propertyNamed: name put: value [
	^ self privateState cacheAt: name put: value
]

{ #category : #accessing }
MooseObject >> removeFromModel [
	^ self mooseModel
		ifNil: [ self ]
		ifNotNil: [ :model | model removeEntity: self ]
]

{ #category : #initialization }
MooseObject >> resetMooseName [
	"If needed I reset my moose name in the MooseModel. I return true if my MooseName was updated and false if it was not."

	(self hasUniqueMooseNameInModel and: [ self hasMooseModel ]) ifFalse: [ ^ false ].

	self mooseModel resetMooseNameFor: self.

	^ true
]

{ #category : #initialization }
MooseObject >> resetPrivateState [
	state := self defaultStateClass for: self
]

{ #category : #private }
MooseObject >> suspendAllAnnouncementsDuring: aBlock [
	| currentAnnouncer |	
	currentAnnouncer := self announcer.
	[ 	self announcer: Announcer new.
		aBlock value ]
			ensure: [ self announcer: currentAnnouncer ]
]
